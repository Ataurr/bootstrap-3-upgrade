{"ts":1376825654723,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1376825661956,"patch":[[{"diffs":[[1,"/*\r\n\r\n Style HTML\r\n---------------\r\n\r\n  Written by Nochum Sossonko, (nsossonko@hotmail.com)\r\n\r\n  Based on code initially developed by: Einar Lielmanis, <elfz@laacz.lv>\r\n    http://jsbeautifier.org/\r\n\r\n\r\n  You are free to use this in any way you want, in case you find this useful or working for you.\r\n\r\n  Usage:\r\n    style_html(html_source);\r\n\r\n    style_html(html_source, options);\r\n\r\n  The options are:\r\n    indent_size (default 4)          â€” indentation size,\r\n    indent_char (default space)      â€” character to indent with,\r\n    max_char (default 70)            -  maximum amount of characters per line,\r\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\"\r\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line.\r\n    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted\r\n    indent_scripts (default normal)  - \"keep\"|\"separate\"|\"normal\"\r\n\r\n    e.g.\r\n\r\n    style_html(html_source, {\r\n      'indent_size': 2,\r\n      'indent_char': ' ',\r\n      'max_char': 78,\r\n      'brace_style': 'expand',\r\n      'unformatted': ['a', 'sub', 'sup', 'b', 'i', 'u']\r\n    });\r\n*/\r\n\r\nfunction style_html(html_source, options) {\r\n//Wrapper function to invoke all the necessary constructors and deal with the output.\r\n\r\n  var multi_parser,\r\n      indent_size,\r\n      indent_character,\r\n      max_char,\r\n      brace_style,\r\n      unformatted;\r\n\r\n  options = options || {};\r\n  indent_size = options.indent_size || 4;\r\n  indent_character = options.indent_char || ' ';\r\n  brace_style = options.brace_style || 'collapse';\r\n  max_char = options.max_char == 0 ? Infinity : options.max_char || 70;\r\n  unformatted = options.unformatted || ['a', 'span', 'bdo', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'q', 'sub', 'sup', 'tt', 'i', 'b', 'big', 'small', 'u', 's', 'strike', 'font', 'ins', 'del', 'pre', 'address', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'];\r\n\r\n  function Parser() {\r\n\r\n    this.pos = 0; //Parser position\r\n    this.token = '';\r\n    this.current_mode = 'CONTENT'; //reflects the current Parser mode: TAG/CONTENT\r\n    this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values\r\n      parent: 'parent1',\r\n      parentcount: 1,\r\n      parent1: ''\r\n    };\r\n    this.tag_type = '';\r\n    this.token_text = this.last_token = this.last_text = this.token_type = '';\r\n\r\n    this.Utils = { //Uilities made available to the various functions\r\n      whitespace: \"\\n\\r\\t \".split(''),\r\n      single_token: 'br,input,link,meta,!doctype,basefont,base,area,hr,wbr,param,img,isindex,?xml,embed,?php,?,?='.split(','), //all the single tags for HTML\r\n      extra_liners: 'head,body,/html'.split(','), //for tags that need a line of whitespace before them\r\n      in_array: function (what, arr) {\r\n        for (var i=0; i<arr.length; i++) {\r\n          if (what === arr[i]) {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      }\r\n    }\r\n\r\n    this.get_content = function () { //function to capture regular content between tags\r\n\r\n      var input_char = '',\r\n          content = [],\r\n          space = false; //if a space is needed\r\n\r\n      while (this.input.charAt(this.pos) !== '<') {\r\n        if (this.pos >= this.input.length) {\r\n          return content.length?content.join(''):['', 'TK_EOF'];\r\n        }\r\n\r\n        input_char = this.input.charAt(this.pos);\r\n        this.pos++;\r\n        this.line_char_count++;\r\n\r\n        if (this.Utils.in_array(input_char, this.Utils.whitespace)) {\r\n          if (content.length) {\r\n            space = true;\r\n          }\r\n          this.line_char_count--;\r\n          continue; //don't want to insert unnecessary space\r\n        }\r\n        else if (space) {\r\n          if (this.line_char_count >= this.max_char) { //insert a line when the max_char is reached\r\n            content.push('\\n');\r\n            for (var i=0; i<this.indent_level; i++) {\r\n              content.push(this.indent_string);\r\n            }\r\n            this.line_char_count = 0;\r\n          }\r\n          else{\r\n            content.push(' ');\r\n            this.line_char_count++;\r\n          }\r\n          space = false;\r\n        }\r\n        content.push(input_char); //letter at-a-time (or string) inserted to an array\r\n      }\r\n      return content.length?content.join(''):'';\r\n    }\r\n\r\n    this.get_contents_to = function (name) { //get the full content of a script or style to pass to js_beautify\r\n      if (this.pos == this.input.length) {\r\n        return ['', 'TK_EOF'];\r\n      }\r\n      var input_char = '';\r\n      var content = '';\r\n      var reg_match = new RegExp('\\<\\/' + name + '\\\\s*\\>', 'igm');\r\n      reg_match.lastIndex = this.pos;\r\n      var reg_array = reg_match.exec(this.input);\r\n      var end_script = reg_array?reg_array.index:this.input.length; //absolute end of script\r\n      if(this.pos < end_script) { //get everything in between the script tags\r\n        content = this.input.substring(this.pos, end_script);\r\n        this.pos = end_script;\r\n      }\r\n      return content;\r\n    }\r\n\r\n    this.record_tag = function (tag){ //function to record a tag and its parent in this.tags Object\r\n      if (this.tags[tag + 'count']) { //check for the existence of this tag type\r\n        this.tags[tag + 'count']++;\r\n        this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level\r\n      }\r\n      else { //otherwise initialize this tag type\r\n        this.tags[tag + 'count'] = 1;\r\n        this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level\r\n      }\r\n      this.tags[tag + this.tags[tag + 'count'] + 'parent'] = this.tags.parent; //set the parent (i.e. in the case of a div this.tags.div1parent)\r\n      this.tags.parent = tag + this.tags[tag + 'count']; //and make this the current parent (i.e. in the case of a div 'div1')\r\n    }\r\n\r\n    this.retrieve_tag = function (tag) { //function to retrieve the opening tag to the corresponding closer\r\n      if (this.tags[tag + 'count']) { //if the openener is not in the Object we ignore it\r\n        var temp_parent = this.tags.parent; //check to see if it's a closable tag.\r\n        while (temp_parent) { //till we reach '' (the initial value);\r\n          if (tag + this.tags[tag + 'count'] === temp_parent) { //if this is it use it\r\n            break;\r\n          }\r\n          temp_parent = this.tags[temp_parent + 'parent']; //otherwise keep on climbing up the DOM Tree\r\n        }\r\n        if (temp_parent) { //if we caught something\r\n          this.indent_level = this.tags[tag + this.tags[tag + 'count']]; //set the indent_level accordingly\r\n          this.tags.parent = this.tags[temp_parent + 'parent']; //and set the current parent\r\n        }\r\n        delete this.tags[tag + this.tags[tag + 'count'] + 'parent']; //delete the closed tags parent reference...\r\n        delete this.tags[tag + this.tags[tag + 'count']]; //...and the tag itself\r\n        if (this.tags[tag + 'count'] == 1) {\r\n          delete this.tags[tag + 'count'];\r\n        }\r\n        else {\r\n          this.tags[tag + 'count']--;\r\n        }\r\n      }\r\n    }\r\n\r\n    this.get_tag = function () { //function to get a full tag and parse its type\r\n      var input_char = '',\r\n          content = [],\r\n          space = false,\r\n          tag_start, tag_end;\r\n\r\n      do {\r\n        if (this.pos >= this.input.length) {\r\n          return content.length?content.join(''):['', 'TK_EOF'];\r\n        }\r\n\r\n        input_char = this.input.charAt(this.pos);\r\n        this.pos++;\r\n        this.line_char_count++;\r\n\r\n        if (this.Utils.in_array(input_char, this.Utils.whitespace)) { //don't want to insert unnecessary space\r\n          space = true;\r\n          this.line_char_count--;\r\n          continue;\r\n        }\r\n\r\n        if (input_char === \"'\" || input_char === '\"') {\r\n          if (!content[1] || content[1] !== '!') { //if we're in a comment strings don't get treated specially\r\n            input_char += this.get_unformatted(input_char);\r\n            space = true;\r\n          }\r\n        }\r\n\r\n        if (input_char === '=') { //no space before =\r\n          space = false;\r\n        }\r\n\r\n        if (content.length && content[content.length-1] !== '=' && input_char !== '>'\r\n            && space) { //no space after = or before >\r\n          if (this.line_char_count >= this.max_char) {\r\n            this.print_newline(false, content);\r\n            this.line_char_count = 0;\r\n          }\r\n          else {\r\n            content.push(' ');\r\n            this.line_char_count++;\r\n          }\r\n          space = false;\r\n        }\r\n        if (input_char === '<') {\r\n            tag_start = this.pos - 1;\r\n        }\r\n        content.push(input_char); //inserts character at-a-time (or string)\r\n      } while (input_char !== '>');\r\n\r\n      var tag_complete = content.join('');\r\n      var tag_index;\r\n      if (tag_complete.indexOf(' ') != -1) { //if there's whitespace, thats where the tag name ends\r\n        tag_index = tag_complete.indexOf(' ');\r\n      }\r\n      else { //otherwise go with the tag ending\r\n        tag_index = tag_complete.indexOf('>');\r\n      }\r\n      var tag_check = tag_complete.substring(1, tag_index).toLowerCase();\r\n      if (tag_complete.charAt(tag_complete.length-2) === '/' ||\r\n          this.Utils.in_array(tag_check, this.Utils.single_token)) { //if this tag name is a single tag type (either in the list or has a closing /)\r\n        this.tag_type = 'SINGLE';\r\n      }\r\n      else if (tag_check === 'script') { //for later script handling\r\n        this.record_tag(tag_check);\r\n        this.tag_type = 'SCRIPT';\r\n      }\r\n      else if (tag_check === 'style') { //for future style handling (for now it justs uses get_content)\r\n        this.record_tag(tag_check);\r\n        this.tag_type = 'STYLE';\r\n      }\r\n      else if (this.Utils.in_array(tag_check, unformatted)) { // do not reformat the \"unformatted\" tags\r\n        var comment = this.get_unformatted('</'+tag_check+'>', tag_complete); //...delegate to get_unformatted function\r\n        content.push(comment);\r\n        // Preserve collapsed whitespace either before or after this tag.\r\n        if (tag_start > 0 && this.Utils.in_array(this.input.charAt(tag_start - 1), this.Utils.whitespace)){\r\n            content.splice(0, 0, this.input.charAt(tag_start - 1));\r\n        }\r\n        tag_end = this.pos - 1;\r\n        if (this.Utils.in_array(this.input.charAt(tag_end + 1), this.Utils.whitespace)){\r\n            content.push(this.input.charAt(tag_end + 1));\r\n        }\r\n        this.tag_type = 'SINGLE';\r\n      }\r\n      else if (tag_check.charAt(0) === '!') { //peek for <!-- comment\r\n        if (tag_check.indexOf('[if') != -1) { //peek for <!--[if conditional comment\r\n          if (tag_complete.indexOf('!IE') != -1) { //this type needs a closing --> so...\r\n            var comment = this.get_unformatted('-->', tag_complete); //...delegate to get_unformatted\r\n            content.push(comment);\r\n          }\r\n          this.tag_type = 'START';\r\n        }\r\n        else if (tag_check.indexOf('[endif') != -1) {//peek for <!--[endif end conditional comment\r\n          this.tag_type = 'END';\r\n          this.unindent();\r\n        }\r\n        else if (tag_check.indexOf('[cdata[') != -1) { //if it's a <[cdata[ comment...\r\n          var comment = this.get_unformatted(']]>', tag_complete); //...delegate to get_unformatted function\r\n          content.push(comment);\r\n          this.tag_type = 'SINGLE'; //<![CDATA[ comments are treated like single tags\r\n        }\r\n        else {\r\n          var comment = this.get_unformatted('-->', tag_complete);\r\n          content.push(comment);\r\n          this.tag_type = 'SINGLE';\r\n        }\r\n      }\r\n      else {\r\n        if (tag_check.charAt(0) === '/') { //this tag is a double tag so check for tag-ending\r\n          this.retrieve_tag(tag_check.substring(1)); //remove it and all ancestors\r\n          this.tag_type = 'END';\r\n        }\r\n        else { //otherwise it's a start-tag\r\n          this.record_tag(tag_check); //push it on the tag stack\r\n          this.tag_type = 'START';\r\n        }\r\n        if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) { //check if this double needs an extra line\r\n          this.print_newline(true, this.output);\r\n        }\r\n      }\r\n      return content.join(''); //returns fully formatted tag\r\n    }\r\n\r\n    this.get_unformatted = function (delimiter, orig_tag) { //function to return unformatted content in its entirety\r\n\r\n      if (orig_tag && orig_tag.indexOf(delimiter) != -1) {\r\n        return '';\r\n      }\r\n      var input_char = '';\r\n      var content = '';\r\n      var space = true;\r\n      do {\r\n\r\n        if (this.pos >= this.input.length) {\r\n          return content;\r\n        }\r\n\r\n        input_char = this.input.charAt(this.pos);\r\n        this.pos++\r\n\r\n        if (this.Utils.in_array(input_char, this.Utils.whitespace)) {\r\n          if (!space) {\r\n            this.line_char_count--;\r\n            continue;\r\n          }\r\n          if (input_char === '\\n' || input_char === '\\r') {\r\n            content += '\\n';\r\n            /*  Don't change tab indention for unformatted blocks.  If using code for html editing, this will greatly affect <pre> tags if they are specified in the 'unformatted array'\r\n            for (var i=0; i<this.indent_level; i++) {\r\n              content += this.indent_string;\r\n            }\r\n            space = false; //...and make sure other indentation is erased\r\n            */\r\n            this.line_char_count = 0;\r\n            continue;\r\n          }\r\n        }\r\n        content += input_char;\r\n        this.line_char_count++;\r\n        space = true;\r\n\r\n\r\n      } while (content.indexOf(delimiter) == -1);\r\n      return content;\r\n    }\r\n\r\n    this.get_token = function () { //initial handler for token-retrieval\r\n      var token;\r\n\r\n      if (this.last_token === 'TK_TAG_SCRIPT' || this.last_token === 'TK_TAG_STYLE') { //check if we need to format javascript\r\n       var type = this.last_token.substr(7)\r\n       token = this.get_contents_to(type);\r\n        if (typeof token !== 'string') {\r\n          return token;\r\n        }\r\n        return [token, 'TK_' + type];\r\n      }\r\n      if (this.current_mode === 'CONTENT') {\r\n        token = this.get_content();\r\n        if (typeof token !== 'string') {\r\n          return token;\r\n        }\r\n        else {\r\n          return [token, 'TK_CONTENT'];\r\n        }\r\n      }\r\n\r\n      if (this.current_mode === 'TAG') {\r\n        token = this.get_tag();\r\n        if (typeof token !== 'string') {\r\n          return token;\r\n        }\r\n        else {\r\n          var tag_name_type = 'TK_TAG_' + this.tag_type;\r\n          return [token, tag_name_type];\r\n        }\r\n      }\r\n    }\r\n\r\n    this.get_full_indent = function (level) {\r\n      level = this.indent_level + level || 0;\r\n      if (level < 1)\r\n        return '';\r\n\r\n      return Array(level + 1).join(this.indent_string);\r\n    }\r\n\r\n\r\n    this.printer = function (js_source, indent_character, indent_size, max_char, brace_style) { //handles input/output and some other printing functions\r\n\r\n      this.input = js_source || ''; //gets the input for the Parser\r\n      this.output = [];\r\n      this.indent_character = indent_character;\r\n      this.indent_string = '';\r\n      this.indent_size = indent_size;\r\n      this.brace_style = brace_style;\r\n      this.indent_level = 0;\r\n      this.max_char = max_char;\r\n      this.line_char_count = 0; //count to see if max_char was exceeded\r\n\r\n      for (var i=0; i<this.indent_size; i++) {\r\n        this.indent_string += this.indent_character;\r\n      }\r\n\r\n      this.print_newline = function (ignore, arr) {\r\n        this.line_char_count = 0;\r\n        if (!arr || !arr.length) {\r\n          return;\r\n        }\r\n        if (!ignore) { //we might want the extra line\r\n          while (this.Utils.in_array(arr[arr.length-1], this.Utils.whitespace)) {\r\n            arr.pop();\r\n          }\r\n        }\r\n        arr.push('\\n');\r\n        for (var i=0; i<this.indent_level; i++) {\r\n          arr.push(this.indent_string);\r\n        }\r\n      }\r\n\r\n      this.print_token = function (text) {\r\n        this.output.push(text);\r\n      }\r\n\r\n      this.indent = function () {\r\n        this.indent_level++;\r\n      }\r\n\r\n      this.unindent = function () {\r\n        if (this.indent_level > 0) {\r\n          this.indent_level--;\r\n        }\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /*_____________________--------------------_____________________*/\r\n\r\n  multi_parser = new Parser(); //wrapping functions Parser\r\n  multi_parser.printer(html_source, indent_character, indent_size, max_char, brace_style); //initialize starting values\r\n\r\n  while (true) {\r\n      var t = multi_parser.get_token();\r\n      multi_parser.token_text = t[0];\r\n      multi_parser.token_type = t[1];\r\n\r\n    if (multi_parser.token_type === 'TK_EOF') {\r\n      break;\r\n    }\r\n\r\n    switch (multi_parser.token_type) {\r\n      case 'TK_TAG_START':\r\n        multi_parser.print_newline(false, multi_parser.output);\r\n        multi_parser.print_token(multi_parser.token_text);\r\n        multi_parser.indent();\r\n        multi_parser.current_mode = 'CONTENT';\r\n        break;\r\n      case 'TK_TAG_STYLE':\r\n      case 'TK_TAG_SCRIPT':\r\n        multi_parser.print_newline(false, multi_parser.output);\r\n        multi_parser.print_token(multi_parser.token_text);\r\n        multi_parser.current_mode = 'CONTENT';\r\n        break;\r\n      case 'TK_TAG_END':\r\n        //Print new line only if the tag has no content and has child\r\n        if (multi_parser.last_token === 'TK_CONTENT' && multi_parser.last_text === '') {\r\n            var tag_name = multi_parser.token_text.match(/\\w+/)[0];\r\n            var tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length -1].match(/<\\s*(\\w+)/);\r\n            if (tag_extracted_from_last_output === null || tag_extracted_from_last_output[1] !== tag_name)\r\n                multi_parser.print_newline(true, multi_parser.output);\r\n        }\r\n        multi_parser.print_token(multi_parser.token_text);\r\n        multi_parser.current_mode = 'CONTENT';\r\n        break;\r\n      case 'TK_TAG_SINGLE':\r\n        // Don't add a newline before elements that should remain unformatted.\r\n        var tag_check = multi_parser.token_text.match(/^\\s*<([a-z]+)/i);\r\n        if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)){\r\n            multi_parser.print_newline(false, multi_parser.output);\r\n        }\r\n        multi_parser.print_token(multi_parser.token_text);\r\n        multi_parser.current_mode = 'CONTENT';\r\n        break;\r\n      case 'TK_CONTENT':\r\n        if (multi_parser.token_text !== '') {\r\n          multi_parser.print_token(multi_parser.token_text);\r\n        }\r\n        multi_parser.current_mode = 'TAG';\r\n        break;\r\n      case 'TK_STYLE':\r\n      case 'TK_SCRIPT':\r\n        if (multi_parser.token_text !== '') {\r\n          multi_parser.output.push('\\n');\r\n          var text = multi_parser.token_text;\r\n          if (multi_parser.token_type == 'TK_SCRIPT') {\r\n            var _beautifier = typeof js_beautify == 'function' && js_beautify;\r\n          } else if (multi_parser.token_type == 'TK_STYLE') {\r\n            var _beautifier = typeof css_beautify == 'function' && css_beautify;\r\n          }\r\n\r\n          if (options.indent_scripts == \"keep\") {\r\n            var script_indent_level = 0;\r\n          } else if (options.indent_scripts == \"separate\") {\r\n            var script_indent_level = -multi_parser.indent_level;\r\n          } else {\r\n            var script_indent_level = 1;\r\n          }\r\n\r\n          var indentation = multi_parser.get_full_indent(script_indent_level);\r\n          if (_beautifier) {\r\n            // call the Beautifier if avaliable\r\n            text = _beautifier(text.replace(/^\\s*/, indentation), options);\r\n          } else {\r\n            // simply indent the string otherwise\r\n            var white = text.match(/^\\s*/)[0];\r\n            var _level = white.match(/[^\\n\\r]*$/)[0].split(multi_parser.indent_string).length - 1;\r\n            var reindent = multi_parser.get_full_indent(script_indent_level -_level);\r\n            text = text.replace(/^\\s*/, indentation)\r\n                   .replace(/\\r\\n|\\r|\\n/g, '\\n' + reindent)\r\n                   .replace(/\\s*$/, '');\r\n          }\r\n          if (text) {\r\n            multi_parser.print_token(text);\r\n            multi_parser.print_newline(true, multi_parser.output);\r\n          }\r\n        }\r\n        multi_parser.current_mode = 'TAG';\r\n        break;\r\n    }\r\n    multi_parser.last_token = multi_parser.token_type;\r\n    multi_parser.last_text = multi_parser.token_text;\r\n  }\r\n  return multi_parser.output.join('');\r\n}\r\n\r\n/*\r\n\r\n CSS Beautifier\r\n---------------\r\n\r\n    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)\r\n\r\n    Based on code initially developed by: Einar Lielmanis, <elfz@laacz.lv>\r\n        http://jsbeautifier.org/\r\n\r\n\r\n    You are free to use this in any way you want, in case you find this useful or working for you.\r\n\r\n    Usage:\r\n        css_beautify(source_text);\r\n        css_beautify(source_text, options);\r\n\r\n    The options are:\r\n        indent_size (default 4)          â€” indentation size,\r\n        indent_char (default space)      â€” character to indent with,\r\n\r\n    e.g\r\n\r\n    css_beautify(css_source_text, {\r\n      'indent_size': 1,\r\n      'indent_char': '\\t'\r\n    });\r\n*/\r\n\r\n// http://www.w3.org/TR/CSS21/syndata.html#tokenization\r\n// http://www.w3.org/TR/css3-syntax/\r\nfunction css_beautify(source_text, options) {\r\n    options = options || {};\r\n    var indentSize = options.indent_size || 4;\r\n    var indentCharacter = options.indent_char || ' ';\r\n\r\n    // compatibility\r\n    if (typeof indentSize == \"string\")\r\n        indentSize = parseInt(indentSize);\r\n\r\n\r\n    // tokenizer\r\n    var whiteRe = /^\\s+$/;\r\n    var wordRe = /[\\w$\\-_]/;\r\n\r\n    var pos = -1, ch;\r\n    function next() {\r\n        return ch = source_text.charAt(++pos)\r\n    }\r\n    function peek() {\r\n        return source_text.charAt(pos+1)\r\n    }\r\n    function eatString(comma) {\r\n        var start = pos;\r\n        while(next()){\r\n            if (ch==\"\\\\\"){\r\n                next();\r\n                next();\r\n            } else if (ch == comma) {\r\n                break;\r\n            } else if (ch == \"\\n\") {\r\n                break;\r\n            }\r\n        }\r\n        return source_text.substring(start, pos + 1);\r\n    }\r\n\r\n    function eatWhitespace() {\r\n        var start = pos;\r\n        while (whiteRe.test(peek()))\r\n            pos++;\r\n        return pos != start;\r\n    }\r\n\r\n    function skipWhitespace() {\r\n        var start = pos;\r\n        do{\r\n        }while (whiteRe.test(next()))\r\n        return pos != start + 1;\r\n    }\r\n\r\n    function eatComment() {\r\n        var start = pos;\r\n        next();\r\n        while (next()) {\r\n            if (ch == \"*\" && peek() == \"/\") {\r\n                pos ++;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return source_text.substring(start, pos + 1);\r\n    }\r\n\r\n\r\n    function lookBack(str, index) {\r\n        return output.slice(-str.length + (index||0), index).join(\"\").toLowerCase() == str;\r\n    }\r\n\r\n    // printer\r\n    var indentString = source_text.match(/^[\\r\\n]*[\\t ]*/)[0];\r\n    var singleIndent = Array(indentSize + 1).join(indentCharacter);\r\n    var indentLevel = 0;\r\n    function indent() {\r\n        indentLevel++;\r\n        indentString += singleIndent;\r\n    }\r\n    function outdent() {\r\n        indentLevel--;\r\n        indentString = indentString.slice(0, -indentSize);\r\n    }\r\n\r\n    var print = {}\r\n    print[\"{\"] = function(ch) {\r\n        print.singleSpace();\r\n        output.push(ch);\r\n        print.newLine();\r\n    }\r\n    print[\"}\"] = function(ch) {\r\n        print.newLine();\r\n        output.push(ch);\r\n        print.newLine();\r\n    }\r\n\r\n    print.newLine = function(keepWhitespace) {\r\n        if (!keepWhitespace)\r\n            while (whiteRe.test(output[output.length - 1]))\r\n                output.pop();\r\n\r\n        if (output.length)\r\n            output.push('\\n');\r\n        if (indentString)\r\n            output.push(indentString);\r\n    }\r\n    print.singleSpace = function() {\r\n        if (output.length && !whiteRe.test(output[output.length - 1]))\r\n            output.push(' ');\r\n    }\r\n    var output = [];\r\n    if (indentString)\r\n        output.push(indentString);\r\n    /*_____________________--------------------_____________________*/\r\n\r\n    while(true) {\r\n        var isAfterSpace = skipWhitespace();\r\n\r\n        if (!ch)\r\n            break;\r\n\r\n        if (ch == '{') {\r\n            indent();\r\n            print[\"{\"](ch);\r\n        } else if (ch == '}') {\r\n            outdent();\r\n            print[\"}\"](ch);\r\n        } else if (ch == '\"' || ch == '\\'') {\r\n            output.push(eatString(ch))\r\n        } else if (ch == ';') {\r\n            output.push(ch, '\\n', indentString);\r\n        } else if (ch == '/' && peek() == '*') { // comment\r\n            print.newLine();\r\n            output.push(eatComment(), \"\\n\", indentString);\r\n        } else if (ch == '(') { // may be a url\r\n            if (lookBack(\"url\", -1)) {\r\n              output.push(ch);\r\n              eatWhitespace();\r\n              if (next()) {\r\n                if (ch != ')' && ch != '\"' && ch != '\\'')\r\n                    output.push(eatString(')'));\r\n                else\r\n                    pos--;\r\n              }\r\n            } else {\r\n              if (isAfterSpace)\r\n                  print.singleSpace();\r\n              output.push(ch);\r\n              eatWhitespace();\r\n            }\r\n        } else if (ch == ')') {\r\n            output.push(ch);\r\n        } else if (ch == ',') {\r\n            eatWhitespace();\r\n            output.push(ch);\r\n            print.singleSpace();\r\n        } else if (ch == ']') {\r\n            output.push(ch);\r\n        }  else if (ch == '[' || ch == '=') { // no whitespace before or after\r\n            eatWhitespace();\r\n            output.push(ch);\r\n        } else {\r\n            if (isAfterSpace)\r\n                print.singleSpace();\r\n\r\n            output.push(ch);\r\n        }\r\n    }\r\n\r\n\r\n    var sweetCode = output.join('').replace(/[\\n ]+$/, '');\r\n    return sweetCode;\r\n}\r\n\r\n\r\nif (typeof exports !== \"undefined\")\r\n    exports.css_beautify = css_beautify;\r\n\r\n/*jslint onevar: false, plusplus: false */\r\n/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */\r\n/*\r\n\r\n JS Beautifier\r\n---------------\r\n\r\n\r\n  Written by Einar Lielmanis, <einar@jsbeautifier.org>\r\n      http://jsbeautifier.org/\r\n\r\n  Originally converted to javascript by Vital, <vital76@gmail.com>\r\n  \"End braces on own line\" added by Chris J. Shull, <chrisjshull@gmail.com>\r\n\r\n  You are free to use this in any way you want, in case you find this useful or working for you.\r\n\r\n  Usage:\r\n    js_beautify(js_source_text);\r\n    js_beautify(js_source_text, options);\r\n\r\n  The options are:\r\n    indent_size (default 4)          - indentation size,\r\n    indent_char (default space)      - character to indent with,\r\n    preserve_newlines (default true) - whether existing line breaks should be preserved,\r\n    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,\r\n\r\n    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.\r\n\r\n            jslint_happy   !jslint_happy\r\n            ---------------------------------\r\n             function ()      function()\r\n\r\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\" | \"expand-strict\"\r\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line.\r\n\r\n            expand-strict: put brace on own line even in such cases:\r\n\r\n                var a =\r\n                {\r\n                    a: 5,\r\n                    b: 6\r\n                }\r\n            This mode may break your scripts - e.g \"return { a: 1 }\" will be broken into two lines, so beware.\r\n\r\n    space_before_conditional (default true) - should the space before conditional statement be added, \"if(true)\" vs \"if (true)\",\r\n\r\n    unescape_strings (default false) - should printable characters in strings encoded in \\xNN notation be unescaped, \"example\" vs \"\\x65\\x78\\x61\\x6d\\x70\\x6c\\x65\"\r\n\r\n    e.g\r\n\r\n    js_beautify(js_source_text, {\r\n      'indent_size': 1,\r\n      'indent_char': '\\t'\r\n    });\r\n\r\n\r\n*/\r\n\r\n\r\n\r\nfunction js_beautify(js_source_text, options) {\r\n\r\n    var input, output, token_text, last_type, last_text, last_last_text, last_word, flags, flag_store, indent_string;\r\n    var whitespace, wordchar, punct, parser_pos, line_starters, digits;\r\n    var prefix, token_type, do_block_just_closed;\r\n    var wanted_newline, just_added_newline, n_newlines;\r\n    var preindent_string = '';\r\n\r\n\r\n    // Some interpreters have unexpected results with foo = baz || bar;\r\n    options = options ? options : {};\r\n\r\n    var opt_brace_style;\r\n\r\n    // compatibility\r\n    if (options.space_after_anon_function !== undefined && options.jslint_happy === undefined) {\r\n        options.jslint_happy = options.space_after_anon_function;\r\n    }\r\n    if (options.braces_on_own_line !== undefined) { //graceful handling of deprecated option\r\n        opt_brace_style = options.braces_on_own_line ? \"expand\" : \"collapse\";\r\n    }\r\n    opt_brace_style = options.brace_style ? options.brace_style : (opt_brace_style ? opt_brace_style : \"collapse\");\r\n\r\n\r\n    var opt_indent_size = options.indent_size ? options.indent_size : 4,\r\n        opt_indent_char = options.indent_char ? options.indent_char : ' ',\r\n        opt_preserve_newlines = typeof options.preserve_newlines === 'undefined' ? true : options.preserve_newlines,\r\n        opt_break_chained_methods = typeof options.break_chained_methods === 'undefined' ? false : options.break_chained_methods,\r\n        opt_max_preserve_newlines = typeof options.max_preserve_newlines === 'undefined' ? false : options.max_preserve_newlines,\r\n        opt_jslint_happy = options.jslint_happy === 'undefined' ? false : options.jslint_happy,\r\n        opt_keep_array_indentation = typeof options.keep_array_indentation === 'undefined' ? false : options.keep_array_indentation,\r\n        opt_space_before_conditional = typeof options.space_before_conditional === 'undefined' ? true : options.space_before_conditional,\r\n        opt_unescape_strings = typeof options.unescape_strings === 'undefined' ? false : options.unescape_strings;\r\n\r\n    just_added_newline = false;\r\n\r\n    // cache the source's length.\r\n    var input_length = js_source_text.length;\r\n\r\n    function trim_output(eat_newlines) {\r\n        eat_newlines = typeof eat_newlines === 'undefined' ? false : eat_newlines;\r\n        while (output.length && (output[output.length - 1] === ' '\r\n            || output[output.length - 1] === indent_string\r\n            || output[output.length - 1] === preindent_string\r\n            || (eat_newlines && (output[output.length - 1] === '\\n' || output[output.length - 1] === '\\r')))) {\r\n            output.pop();\r\n        }\r\n    }\r\n\r\n    function trim(s) {\r\n        return s.replace(/^\\s\\s*|\\s\\s*$/, '');\r\n    }\r\n\r\n    // we could use just string.split, but\r\n    // IE doesn't like returning empty strings\r\n    function split_newlines(s) {\r\n        //return s.split(/\\x0d\\x0a|\\x0a/);\r\n\r\n        s = s.replace(/\\x0d/g, '');\r\n        var out = [],\r\n            idx = s.indexOf(\"\\n\");\r\n        while (idx !== -1) {\r\n            out.push(s.substring(0, idx));\r\n            s = s.substring(idx + 1);\r\n            idx = s.indexOf(\"\\n\");\r\n        }\r\n        if (s.length) {\r\n            out.push(s);\r\n        }\r\n        return out;\r\n    }\r\n\r\n    function force_newline() {\r\n        var old_keep_array_indentation = opt_keep_array_indentation;\r\n        opt_keep_array_indentation = false;\r\n        print_newline();\r\n        opt_keep_array_indentation = old_keep_array_indentation;\r\n    }\r\n\r\n    function print_newline(ignore_repeated, reset_statement_flags) {\r\n\r\n        flags.eat_next_space = false;\r\n        if (opt_keep_array_indentation && is_array(flags.mode)) {\r\n            return;\r\n        }\r\n\r\n        ignore_repeated = typeof ignore_repeated === 'undefined' ? true : ignore_repeated;\r\n        reset_statement_flags = typeof reset_statement_flags === 'undefined' ? true : reset_statement_flags;\r\n\r\n        if (reset_statement_flags) {\r\n            flags.if_line = false;\r\n            flags.chain_extra_indentation = 0;\r\n        }\r\n\r\n        trim_output();\r\n\r\n        if (!output.length) {\r\n            return; // no newline on start of file\r\n        }\r\n\r\n        if (output[output.length - 1] !== \"\\n\" || !ignore_repeated) {\r\n            just_added_newline = true;\r\n            output.push(\"\\n\");\r\n        }\r\n        if (preindent_string) {\r\n            output.push(preindent_string);\r\n        }\r\n        for (var i = 0; i < flags.indentation_level + flags.chain_extra_indentation; i += 1) {\r\n            output.push(indent_string);\r\n        }\r\n        if (flags.var_line && flags.var_line_reindented) {\r\n            output.push(indent_string); // skip space-stuffing, if indenting with a tab\r\n        }\r\n    }\r\n\r\n\r\n\r\n    function print_single_space() {\r\n\r\n        if (last_type === 'TK_COMMENT') {\r\n            return print_newline();\r\n        }\r\n        if (flags.eat_next_space) {\r\n            flags.eat_next_space = false;\r\n            return;\r\n        }\r\n        var last_output = ' ';\r\n        if (output.length) {\r\n            last_output = output[output.length - 1];\r\n        }\r\n        if (last_output !== ' ' && last_output !== '\\n' && last_output !== indent_string) { // prevent occassional duplicate space\r\n            output.push(' ');\r\n        }\r\n    }\r\n\r\n\r\n    function print_token() {\r\n        just_added_newline = false;\r\n        flags.eat_next_space = false;\r\n        output.push(token_text);\r\n    }\r\n\r\n    function indent() {\r\n        flags.indentation_level += 1;\r\n    }\r\n\r\n\r\n    function remove_indent() {\r\n        if (output.length && output[output.length - 1] === indent_string) {\r\n            output.pop();\r\n        }\r\n    }\r\n\r\n    function set_mode(mode) {\r\n        if (flags) {\r\n            flag_store.push(flags);\r\n        }\r\n        flags = {\r\n            previous_mode: flags ? flags.mode : 'BLOCK',\r\n            mode: mode,\r\n            var_line: false,\r\n            var_line_tainted: false,\r\n            var_line_reindented: false,\r\n            in_html_comment: false,\r\n            if_line: false,\r\n            chain_extra_indentation: 0,\r\n            in_case_statement: false, // switch(..){ INSIDE HERE }\r\n            in_case: false, // we're on the exact line with \"case 0:\"\r\n            case_body: false, // the indented case-action block\r\n            eat_next_space: false,\r\n            indentation_level: (flags ? flags.indentation_level + ((flags.var_line && flags.var_line_reindented) ? 1 : 0) : 0),\r\n            ternary_depth: 0\r\n        };\r\n    }\r\n\r\n    function is_array(mode) {\r\n        return mode === '[EXPRESSION]' || mode === '[INDENTED-EXPRESSION]';\r\n    }\r\n\r\n    function is_expression(mode) {\r\n        return in_array(mode, ['[EXPRESSION]', '(EXPRESSION)', '(FOR-EXPRESSION)', '(COND-EXPRESSION)']);\r\n    }\r\n\r\n    function restore_mode() {\r\n        do_block_just_closed = flags.mode === 'DO_BLOCK';\r\n        if (flag_store.length > 0) {\r\n            var mode = flags.mode;\r\n            flags = flag_store.pop();\r\n            flags.previous_mode = mode;\r\n        }\r\n    }\r\n\r\n    function all_lines_start_with(lines, c) {\r\n        for (var i = 0; i < lines.length; i++) {\r\n            var line = trim(lines[i]);\r\n            if (line.charAt(0) !== c) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function is_special_word(word) {\r\n        return in_array(word, ['case', 'return', 'do', 'if', 'throw', 'else']);\r\n    }\r\n\r\n    function in_array(what, arr) {\r\n        for (var i = 0; i < arr.length; i += 1) {\r\n            if (arr[i] === what) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function look_up(exclude) {\r\n        var local_pos = parser_pos;\r\n        var c = input.charAt(local_pos);\r\n        while (in_array(c, whitespace) && c !== exclude) {\r\n            local_pos++;\r\n            if (local_pos >= input_length) {\r\n                return 0;\r\n            }\r\n            c = input.charAt(local_pos);\r\n        }\r\n        return c;\r\n    }\r\n\r\n    function get_next_token() {\r\n        var i;\r\n        var resulting_string;\r\n\r\n        n_newlines = 0;\r\n\r\n        if (parser_pos >= input_length) {\r\n            return ['', 'TK_EOF'];\r\n        }\r\n\r\n        wanted_newline = false;\r\n\r\n        var c = input.charAt(parser_pos);\r\n        parser_pos += 1;\r\n\r\n\r\n        var keep_whitespace = opt_keep_array_indentation && is_array(flags.mode);\r\n\r\n        if (keep_whitespace) {\r\n\r\n            var whitespace_count = 0;\r\n\r\n            while (in_array(c, whitespace)) {\r\n\r\n                if (c === \"\\n\") {\r\n                    trim_output();\r\n                    output.push(\"\\n\");\r\n                    just_added_newline = true;\r\n                    whitespace_count = 0;\r\n                } else {\r\n                    if (c === '\\t') {\r\n                        whitespace_count += 4;\r\n                    } else if (c === '\\r') {\r\n                        // nothing\r\n                    } else {\r\n                        whitespace_count += 1;\r\n                    }\r\n                }\r\n\r\n                if (parser_pos >= input_length) {\r\n                    return ['', 'TK_EOF'];\r\n                }\r\n\r\n                c = input.charAt(parser_pos);\r\n                parser_pos += 1;\r\n\r\n            }\r\n\r\n            if (just_added_newline) {\r\n                for (i = 0; i < whitespace_count; i++) {\r\n                    output.push(' ');\r\n                }\r\n            }\r\n\r\n        } else {\r\n            while (in_array(c, whitespace)) {\r\n\r\n                if (c === \"\\n\") {\r\n                    n_newlines += ((opt_max_preserve_newlines) ? (n_newlines <= opt_max_preserve_newlines) ? 1 : 0 : 1);\r\n                }\r\n\r\n\r\n                if (parser_pos >= input_length) {\r\n                    return ['', 'TK_EOF'];\r\n                }\r\n\r\n                c = input.charAt(parser_pos);\r\n                parser_pos += 1;\r\n\r\n            }\r\n\r\n            if (opt_preserve_newlines) {\r\n                if (n_newlines > 1) {\r\n                    for (i = 0; i < n_newlines; i += 1) {\r\n                        print_newline(i === 0);\r\n                        just_added_newline = true;\r\n                    }\r\n                }\r\n            }\r\n            wanted_newline = n_newlines > 0;\r\n        }\r\n\r\n\r\n        if (in_array(c, wordchar)) {\r\n            if (parser_pos < input_length) {\r\n                while (in_array(input.charAt(parser_pos), wordchar)) {\r\n                    c += input.charAt(parser_pos);\r\n                    parser_pos += 1;\r\n                    if (parser_pos === input_length) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // small and surprisingly unugly hack for 1E-10 representation\r\n            if (parser_pos !== input_length && c.match(/^[0-9]+[Ee]$/) && (input.charAt(parser_pos) === '-' || input.charAt(parser_pos) === '+')) {\r\n\r\n                var sign = input.charAt(parser_pos);\r\n                parser_pos += 1;\r\n\r\n                var t = get_next_token();\r\n                c += sign + t[0];\r\n                return [c, 'TK_WORD'];\r\n            }\r\n\r\n            if (c === 'in') { // hack for 'in' operator\r\n                return [c, 'TK_OPERATOR'];\r\n            }\r\n            if (wanted_newline && last_type !== 'TK_OPERATOR'\r\n                && last_type !== 'TK_EQUALS'\r\n                && !flags.if_line && (opt_preserve_newlines || last_text !== 'var')) {\r\n                print_newline();\r\n            }\r\n            return [c, 'TK_WORD'];\r\n        }\r\n\r\n        if (c === '(' || c === '[') {\r\n            return [c, 'TK_START_EXPR'];\r\n        }\r\n\r\n        if (c === ')' || c === ']') {\r\n            return [c, 'TK_END_EXPR'];\r\n        }\r\n\r\n        if (c === '{') {\r\n            return [c, 'TK_START_BLOCK'];\r\n        }\r\n\r\n        if (c === '}') {\r\n            return [c, 'TK_END_BLOCK'];\r\n        }\r\n\r\n        if (c === ';') {\r\n            return [c, 'TK_SEMICOLON'];\r\n        }\r\n\r\n        if (c === '/') {\r\n            var comment = '';\r\n            // peek for comment /* ... */\r\n            var inline_comment = true;\r\n            if (input.charAt(parser_pos) === '*') {\r\n                parser_pos += 1;\r\n                if (parser_pos < input_length) {\r\n                    while (parser_pos < input_length &&\r\n                        ! (input.charAt(parser_pos) === '*' && input.charAt(parser_pos + 1) && input.charAt(parser_pos + 1) === '/')) {\r\n                        c = input.charAt(parser_pos);\r\n                        comment += c;\r\n                        if (c === \"\\n\" || c === \"\\r\") {\r\n                            inline_comment = false;\r\n                        }\r\n                        parser_pos += 1;\r\n                        if (parser_pos >= input_length) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                parser_pos += 2;\r\n                if (inline_comment && n_newlines === 0) {\r\n                    return ['/*' + comment + '*/', 'TK_INLINE_COMMENT'];\r\n                } else {\r\n                    return ['/*' + comment + '*/', 'TK_BLOCK_COMMENT'];\r\n                }\r\n            }\r\n            // peek for comment // ...\r\n            if (input.charAt(parser_pos) === '/') {\r\n                comment = c;\r\n                while (input.charAt(parser_pos) !== '\\r' && input.charAt(parser_pos) !== '\\n') {\r\n                    comment += input.charAt(parser_pos);\r\n                    parser_pos += 1;\r\n                    if (parser_pos >= input_length) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (wanted_newline) {\r\n                    print_newline();\r\n                }\r\n                return [comment, 'TK_COMMENT'];\r\n            }\r\n\r\n        }\r\n\r\n        if (c === \"'\" || // string\r\n        c === '\"' || // string\r\n        (c === '/' &&\r\n            ((last_type === 'TK_WORD' && is_special_word(last_text)) ||\r\n                (last_text === ')' && in_array(flags.previous_mode, ['(COND-EXPRESSION)', '(FOR-EXPRESSION)'])) ||\r\n                (last_type === 'TK_COMMA' || last_type === 'TK_COMMENT' || last_type === 'TK_START_EXPR' || last_type === 'TK_START_BLOCK' || last_type === 'TK_END_BLOCK' || last_type === 'TK_OPERATOR' || last_type === 'TK_EQUALS' || last_type === 'TK_EOF' || last_type === 'TK_SEMICOLON')))) { // regexp\r\n            var sep = c;\r\n            var esc = false;\r\n            var esc1 = 0;\r\n            var esc2 = 0;\r\n            resulting_string = c;\r\n\r\n            if (parser_pos < input_length) {\r\n                if (sep === '/') {\r\n                    //\r\n                    // handle regexp separately...\r\n                    //\r\n                    var in_char_class = false;\r\n                    while (esc || in_char_class || input.charAt(parser_pos) !== sep) {\r\n                        resulting_string += input.charAt(parser_pos);\r\n                        if (!esc) {\r\n                            esc = input.charAt(parser_pos) === '\\\\';\r\n                            if (input.charAt(parser_pos) === '[') {\r\n                                in_char_class = true;\r\n                            } else if (input.charAt(parser_pos) === ']') {\r\n                                in_char_class = false;\r\n                            }\r\n                        } else {\r\n                            esc = false;\r\n                        }\r\n                        parser_pos += 1;\r\n                        if (parser_pos >= input_length) {\r\n                            // incomplete string/rexp when end-of-file reached.\r\n                            // bail out with what had been received so far.\r\n                            return [resulting_string, 'TK_STRING'];\r\n                        }\r\n                    }\r\n\r\n                } else {\r\n                    //\r\n                    // and handle string also separately\r\n                    //\r\n                    while (esc || input.charAt(parser_pos) !== sep) {\r\n                        resulting_string += input.charAt(parser_pos);\r\n                        if (esc1 && esc1 >= esc2) {\r\n                            esc1 = parseInt(resulting_string.substr(-esc2), 16);\r\n                            if (esc1 && esc1 >= 0x20 && esc1 <= 0x7e) {\r\n                                esc1 = String.fromCharCode(esc1);\r\n                                resulting_string = resulting_string.substr(0, resulting_string.length - esc2 - 2) + (((esc1 === sep) || (esc1 === '\\\\')) ? '\\\\' : '') + esc1;\r\n                            }\r\n                            esc1 = 0;\r\n                        }\r\n                        if (esc1) {\r\n                            esc1++;\r\n                        } else if (!esc) {\r\n                            esc = input.charAt(parser_pos) === '\\\\';\r\n                        } else {\r\n                            esc = false;\r\n                            if (opt_unescape_strings) {\r\n                                if (input.charAt(parser_pos) === 'x') {\r\n                                    esc1++;\r\n                                    esc2 = 2;\r\n                                } else if (input.charAt(parser_pos) === 'u') {\r\n                                    esc1++;\r\n                                    esc2 = 4;\r\n                                }\r\n                            }\r\n                        }\r\n                        parser_pos += 1;\r\n                        if (parser_pos >= input_length) {\r\n                            // incomplete string/rexp when end-of-file reached.\r\n                            // bail out with what had been received so far.\r\n                            return [resulting_string, 'TK_STRING'];\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n\r\n            }\r\n\r\n            parser_pos += 1;\r\n\r\n            resulting_string += sep;\r\n\r\n            if (sep === '/') {\r\n                // regexps may have modifiers /regexp/MOD , so fetch those, too\r\n                while (parser_pos < input_length && in_array(input.charAt(parser_pos), wordchar)) {\r\n                    resulting_string += input.charAt(parser_pos);\r\n                    parser_pos += 1;\r\n                }\r\n            }\r\n            return [resulting_string, 'TK_STRING'];\r\n        }\r\n\r\n        if (c === '#') {\r\n\r\n\r\n            if (output.length === 0 && input.charAt(parser_pos) === '!') {\r\n                // shebang\r\n                resulting_string = c;\r\n                while (parser_pos < input_length && c !== '\\n') {\r\n                    c = input.charAt(parser_pos);\r\n                    resulting_string += c;\r\n                    parser_pos += 1;\r\n                }\r\n                output.push(trim(resulting_string) + '\\n');\r\n                print_newline();\r\n                return get_next_token();\r\n            }\r\n\r\n\r\n\r\n            // Spidermonkey-specific sharp variables for circular references\r\n            // https://developer.mozilla.org/En/Sharp_variables_in_JavaScript\r\n            // http://mxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935\r\n            var sharp = '#';\r\n            if (parser_pos < input_length && in_array(input.charAt(parser_pos), digits)) {\r\n                do {\r\n                    c = input.charAt(parser_pos);\r\n                    sharp += c;\r\n                    parser_pos += 1;\r\n                } while (parser_pos < input_length && c !== '#' && c !== '=');\r\n                if (c === '#') {\r\n                    //\r\n                } else if (input.charAt(parser_pos) === '[' && input.charAt(parser_pos + 1) === ']') {\r\n                    sharp += '[]';\r\n                    parser_pos += 2;\r\n                } else if (input.charAt(parser_pos) === '{' && input.charAt(parser_pos + 1) === '}') {\r\n                    sharp += '{}';\r\n                    parser_pos += 2;\r\n                }\r\n                return [sharp, 'TK_WORD'];\r\n            }\r\n        }\r\n\r\n        if (c === '<' && input.substring(parser_pos - 1, parser_pos + 3) === '<!--') {\r\n            parser_pos += 3;\r\n            c = '<!--';\r\n            while (input.charAt(parser_pos) !== '\\n' && parser_pos < input_length) {\r\n                c += input.charAt(parser_pos);\r\n                parser_pos++;\r\n            }\r\n            flags.in_html_comment = true;\r\n            return [c, 'TK_COMMENT'];\r\n        }\r\n\r\n        if (c === '-' && flags.in_html_comment && input.substring(parser_pos - 1, parser_pos + 2) === '-->') {\r\n            flags.in_html_comment = false;\r\n            parser_pos += 2;\r\n            if (wanted_newline) {\r\n                print_newline();\r\n            }\r\n            return ['-->', 'TK_COMMENT'];\r\n        }\r\n\r\n        if (c === '.') {\r\n            return [c, 'TK_DOT'];\r\n        }\r\n\r\n        if (in_array(c, punct)) {\r\n            while (parser_pos < input_length && in_array(c + input.charAt(parser_pos), punct)) {\r\n                c += input.charAt(parser_pos);\r\n                parser_pos += 1;\r\n                if (parser_pos >= input_length) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (c === ',') {\r\n                return [c, 'TK_COMMA'];\r\n            } else if (c === '=') {\r\n                return [c, 'TK_EQUALS'];\r\n            } else {\r\n                return [c, 'TK_OPERATOR'];\r\n            }\r\n        }\r\n\r\n        return [c, 'TK_UNKNOWN'];\r\n    }\r\n\r\n    //----------------------------------\r\n    indent_string = '';\r\n    while (opt_indent_size > 0) {\r\n        indent_string += opt_indent_char;\r\n        opt_indent_size -= 1;\r\n    }\r\n\r\n    while (js_source_text && (js_source_text.charAt(0) === ' ' || js_source_text.charAt(0) === '\\t')) {\r\n        preindent_string += js_source_text.charAt(0);\r\n        js_source_text = js_source_text.substring(1);\r\n    }\r\n    input = js_source_text;\r\n\r\n    last_word = ''; // last 'TK_WORD' passed\r\n    last_type = 'TK_START_EXPR'; // last token type\r\n    last_text = ''; // last token text\r\n    last_last_text = ''; // pre-last token text\r\n    output = [];\r\n\r\n    do_block_just_closed = false;\r\n\r\n    whitespace = \"\\n\\r\\t \".split('');\r\n    wordchar = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$'.split('');\r\n    digits = '0123456789'.split('');\r\n\r\n    punct = '+ - * / % & ++ -- = += -= *= /= %= == === != !== > < >= <= >> << >>> >>>= >>= <<= && &= | || ! !! , : ? ^ ^= |= ::';\r\n    punct += ' <%= <% %> <?= <? ?>'; // try to be a good boy and try not to break the markup language identifiers\r\n    punct = punct.split(' ');\r\n\r\n    // words which should always start on new line.\r\n    line_starters = 'continue,try,throw,return,var,if,switch,case,default,for,while,break,function'.split(',');\r\n\r\n    // states showing if we are currently in expression (i.e. \"if\" case) - 'EXPRESSION', or in usual block (like, procedure), 'BLOCK'.\r\n    // some formatting depends on that.\r\n    flag_store = [];\r\n    set_mode('BLOCK');\r\n\r\n    parser_pos = 0;\r\n    while (true) {\r\n        var t = get_next_token();\r\n        token_text = t[0];\r\n        token_type = t[1];\r\n        if (token_type === 'TK_EOF') {\r\n            break;\r\n        }\r\n\r\n        switch (token_type) {\r\n\r\n        case 'TK_START_EXPR':\r\n\r\n            if (token_text === '[') {\r\n\r\n                if (last_type === 'TK_WORD' || last_text === ')') {\r\n                    // this is array index specifier, break immediately\r\n                    // a[x], fn()[x]\r\n                    if (in_array(last_text, line_starters)) {\r\n                        print_single_space();\r\n                    }\r\n                    set_mode('(EXPRESSION)');\r\n                    print_token();\r\n                    break;\r\n                }\r\n\r\n                if (flags.mode === '[EXPRESSION]' || flags.mode === '[INDENTED-EXPRESSION]') {\r\n                    if (last_last_text === ']' && last_text === ',') {\r\n                        // ], [ goes to new line\r\n                        if (flags.mode === '[EXPRESSION]') {\r\n                            flags.mode = '[INDENTED-EXPRESSION]';\r\n                            if (!opt_keep_array_indentation) {\r\n                                indent();\r\n                            }\r\n                        }\r\n                        set_mode('[EXPRESSION]');\r\n                        if (!opt_keep_array_indentation) {\r\n                            print_newline();\r\n                        }\r\n                    } else if (last_text === '[') {\r\n                        if (flags.mode === '[EXPRESSION]') {\r\n                            flags.mode = '[INDENTED-EXPRESSION]';\r\n                            if (!opt_keep_array_indentation) {\r\n                                indent();\r\n                            }\r\n                        }\r\n                        set_mode('[EXPRESSION]');\r\n\r\n                        if (!opt_keep_array_indentation) {\r\n                            print_newline();\r\n                        }\r\n                    } else {\r\n                        set_mode('[EXPRESSION]');\r\n                    }\r\n                } else {\r\n                    set_mode('[EXPRESSION]');\r\n                }\r\n\r\n\r\n\r\n            } else {\r\n                if (last_word === 'for') {\r\n                    set_mode('(FOR-EXPRESSION)');\r\n                } else if (in_array(last_word, ['if', 'while'])) {\r\n                    set_mode('(COND-EXPRESSION)');\r\n                } else {\r\n                    set_mode('(EXPRESSION)');\r\n                }\r\n            }\r\n\r\n            if (last_text === ';' || last_type === 'TK_START_BLOCK') {\r\n                print_newline();\r\n            } else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR' || last_type === 'TK_END_BLOCK' || last_text === '.') {\r\n                if (wanted_newline) {\r\n                    print_newline();\r\n                }\r\n                // do nothing on (( and )( and ][ and ]( and .(\r\n            } else if (last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {\r\n                print_single_space();\r\n            } else if (last_word === 'function' || last_word === 'typeof') {\r\n                // function() vs function ()\r\n                if (opt_jslint_happy) {\r\n                    print_single_space();\r\n                }\r\n            } else if (in_array(last_text, line_starters) || last_text === 'catch') {\r\n                if (opt_space_before_conditional) {\r\n                    print_single_space();\r\n                }\r\n            }\r\n            print_token();\r\n\r\n            break;\r\n\r\n        case 'TK_DOT':\r\n\r\n            if (is_special_word(last_text)) {\r\n                print_single_space();\r\n            } else if (last_text === ')') {\r\n                if (opt_break_chained_methods || wanted_newline) {\r\n                    flags.chain_extra_indentation = 1;\r\n                    print_newline(true /* ignore_repeated */, false /* reset_statement_flags */);\r\n                }\r\n            }\r\n\r\n            print_token();\r\n            break;\r\n\r\n        case 'TK_END_EXPR':\r\n            if (token_text === ']') {\r\n                if (opt_keep_array_indentation) {\r\n                    if (last_text === '}') {\r\n                        // trim_output();\r\n                        // print_newline(true);\r\n                        remove_indent();\r\n                        print_token();\r\n                        restore_mode();\r\n                        break;\r\n                    }\r\n                } else {\r\n                    if (flags.mode === '[INDENTED-EXPRESSION]') {\r\n                        if (last_text === ']') {\r\n                            restore_mode();\r\n                            print_newline();\r\n                            print_token();\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            restore_mode();\r\n            print_token();\r\n            break;\r\n\r\n        case 'TK_START_BLOCK':\r\n\r\n            if (last_word === 'do') {\r\n                set_mode('DO_BLOCK');\r\n            } else {\r\n                set_mode('BLOCK');\r\n            }\r\n            if (opt_brace_style === \"expand\" || opt_brace_style === \"expand-strict\") {\r\n                var empty_braces = false;\r\n                if (opt_brace_style === \"expand-strict\") {\r\n                    empty_braces = (look_up() === '}');\r\n                    if (!empty_braces) {\r\n                        print_newline(true);\r\n                    }\r\n                } else {\r\n                    if (last_type !== 'TK_OPERATOR') {\r\n                        if (last_text === '=' || (is_special_word(last_text) && last_text !== 'else')) {\r\n                            print_single_space();\r\n                        } else {\r\n                            print_newline(true);\r\n                        }\r\n                    }\r\n                }\r\n                print_token();\r\n                if (!empty_braces) {\r\n                    indent();\r\n                }\r\n            } else {\r\n                if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {\r\n                    if (last_type === 'TK_START_BLOCK') {\r\n                        print_newline();\r\n                    } else {\r\n                        print_single_space();\r\n                    }\r\n                } else {\r\n                    // if TK_OPERATOR or TK_START_EXPR\r\n                    if (is_array(flags.previous_mode) && last_text === ',') {\r\n                        if (last_last_text === '}') {\r\n                            // }, { in array context\r\n                            print_single_space();\r\n                        } else {\r\n                            print_newline(); // [a, b, c, {\r\n                        }\r\n                    }\r\n                }\r\n                indent();\r\n                print_token();\r\n            }\r\n\r\n            break;\r\n\r\n        case 'TK_END_BLOCK':\r\n            restore_mode();\r\n            if (opt_brace_style === \"expand\" || opt_brace_style === \"expand-strict\") {\r\n                if (last_text !== '{') {\r\n                    print_newline();\r\n                }\r\n                print_token();\r\n            } else {\r\n                if (last_type === 'TK_START_BLOCK') {\r\n                    // nothing\r\n                    if (just_added_newline) {\r\n                        remove_indent();\r\n                    } else {\r\n                        // {}\r\n                        trim_output();\r\n                    }\r\n                } else {\r\n                    if (is_array(flags.mode) && opt_keep_array_indentation) {\r\n                        // we REALLY need a newline here, but newliner would skip that\r\n                        opt_keep_array_indentation = false;\r\n                        print_newline();\r\n                        opt_keep_array_indentation = true;\r\n\r\n                    } else {\r\n                        print_newline();\r\n                    }\r\n                }\r\n                print_token();\r\n            }\r\n            break;\r\n\r\n        case 'TK_WORD':\r\n\r\n            // no, it's not you. even I have problems understanding how this works\r\n            // and what does what.\r\n            if (do_block_just_closed) {\r\n                // do {} ## while ()\r\n                print_single_space();\r\n                print_token();\r\n                print_single_space();\r\n                do_block_just_closed = false;\r\n                break;\r\n            }\r\n\r\n            prefix = 'NONE';\r\n\r\n            if (token_text === 'function') {\r\n                if (flags.var_line && last_type !== 'TK_EQUALS' ) {\r\n                    flags.var_line_reindented = true;\r\n                }\r\n                if ((just_added_newline || last_text === ';') && last_text !== '{'\r\n                && last_type !== 'TK_BLOCK_COMMENT' && last_type !== 'TK_COMMENT') {\r\n                    // make sure there is a nice clean space of at least one blank line\r\n                    // before a new function definition\r\n                    n_newlines = just_added_newline ? n_newlines : 0;\r\n                    if (!opt_preserve_newlines) {\r\n                        n_newlines = 1;\r\n                    }\r\n\r\n                    for (var i = 0; i < 2 - n_newlines; i++) {\r\n                        print_newline(false);\r\n                    }\r\n                }\r\n                if (last_type === 'TK_WORD') {\r\n                    if (last_text === 'get' || last_text === 'set' || last_text === 'new' || last_text === 'return') {\r\n                        print_single_space();\r\n                    } else {\r\n                        print_newline();\r\n                    }\r\n                } else if (last_type === 'TK_OPERATOR' || last_text === '=') {\r\n                    // foo = function\r\n                    print_single_space();\r\n                } else if (is_expression(flags.mode)) {\r\n                    // print nothing\r\n                } else {\r\n                    print_newline();\r\n                }\r\n\r\n                print_token();\r\n                last_word = token_text;\r\n                break;\r\n            }\r\n\r\n            if (token_text === 'case' || (token_text === 'default' && flags.in_case_statement)) {\r\n                print_newline();\r\n                if (flags.case_body) {\r\n                    // switch cases following one another\r\n                    flags.indentation_level--;\r\n                    flags.case_body = false;\r\n                    remove_indent();\r\n                }\r\n                print_token();\r\n                flags.in_case = true;\r\n                flags.in_case_statement = true;\r\n                break;\r\n            }\r\n\r\n            if (last_type === 'TK_END_BLOCK') {\r\n\r\n                if (!in_array(token_text.toLowerCase(), ['else', 'catch', 'finally'])) {\r\n                    prefix = 'NEWLINE';\r\n                } else {\r\n                    if (opt_brace_style === \"expand\" || opt_brace_style === \"end-expand\" || opt_brace_style === \"expand-strict\") {\r\n                        prefix = 'NEWLINE';\r\n                    } else {\r\n                        prefix = 'SPACE';\r\n                        print_single_space();\r\n                    }\r\n                }\r\n            } else if (last_type === 'TK_SEMICOLON' && (flags.mode === 'BLOCK' || flags.mode === 'DO_BLOCK')) {\r\n                prefix = 'NEWLINE';\r\n            } else if (last_type === 'TK_SEMICOLON' && is_expression(flags.mode)) {\r\n                prefix = 'SPACE';\r\n            } else if (last_type === 'TK_STRING') {\r\n                prefix = 'NEWLINE';\r\n            } else if (last_type === 'TK_WORD') {\r\n                if (last_text === 'else') {\r\n                    // eat newlines between ...else *** some_op...\r\n                    // won't preserve extra newlines in this place (if any), but don't care that much\r\n                    trim_output(true);\r\n                }\r\n                prefix = 'SPACE';\r\n            } else if (last_type === 'TK_START_BLOCK') {\r\n                prefix = 'NEWLINE';\r\n            } else if (last_type === 'TK_END_EXPR') {\r\n                print_single_space();\r\n                prefix = 'NEWLINE';\r\n            }\r\n\r\n            if (in_array(token_text, line_starters) && last_text !== ')') {\r\n                if (last_text === 'else') {\r\n                    prefix = 'SPACE';\r\n                } else {\r\n                    prefix = 'NEWLINE';\r\n                }\r\n\r\n            }\r\n\r\n            if (flags.if_line && last_type === 'TK_END_EXPR') {\r\n                flags.if_line = false;\r\n            }\r\n            if (in_array(token_text.toLowerCase(), ['else', 'catch', 'finally'])) {\r\n                if (last_type !== 'TK_END_BLOCK' || opt_brace_style === \"expand\" || opt_brace_style === \"end-expand\" || opt_brace_style === \"expand-strict\") {\r\n                    print_newline();\r\n                } else {\r\n                    trim_output(true);\r\n                    print_single_space();\r\n                }\r\n            } else if (prefix === 'NEWLINE') {\r\n                if (is_special_word(last_text)) {\r\n                    // no newline between 'return nnn'\r\n                    print_single_space();\r\n                } else if (last_type !== 'TK_END_EXPR') {\r\n                    if ((last_type !== 'TK_START_EXPR' || token_text !== 'var') && last_text !== ':') {\r\n                        // no need to force newline on 'var': for (var x = 0...)\r\n                        if (token_text === 'if' && last_word === 'else' && last_text !== '{') {\r\n                            // no newline for } else if {\r\n                            print_single_space();\r\n                        } else {\r\n                            flags.var_line = false;\r\n                            flags.var_line_reindented = false;\r\n                            print_newline();\r\n                        }\r\n                    }\r\n                } else if (in_array(token_text, line_starters) && last_text !== ')') {\r\n                    flags.var_line = false;\r\n                    flags.var_line_reindented = false;\r\n                    print_newline();\r\n                }\r\n            } else if (is_array(flags.mode) && last_text === ',' && last_last_text === '}') {\r\n                print_newline(); // }, in lists get a newline treatment\r\n            } else if (prefix === 'SPACE') {\r\n                print_single_space();\r\n            }\r\n            print_token();\r\n            last_word = token_text;\r\n\r\n            if (token_text === 'var') {\r\n                flags.var_line = true;\r\n                flags.var_line_reindented = false;\r\n                flags.var_line_tainted = false;\r\n            }\r\n\r\n            if (token_text === 'if') {\r\n                flags.if_line = true;\r\n            }\r\n            if (token_text === 'else') {\r\n                flags.if_line = false;\r\n            }\r\n\r\n            break;\r\n\r\n        case 'TK_SEMICOLON':\r\n\r\n            print_token();\r\n            flags.var_line = false;\r\n            flags.var_line_reindented = false;\r\n            if (flags.mode === 'OBJECT') {\r\n                // OBJECT mode is weird and doesn't get reset too well.\r\n                flags.mode = 'BLOCK';\r\n            }\r\n            break;\r\n\r\n        case 'TK_STRING':\r\n\r\n            if (last_type === 'TK_END_EXPR' && in_array(flags.previous_mode, ['(COND-EXPRESSION)', '(FOR-EXPRESSION)'])) {\r\n                print_single_space();\r\n            } else if (last_type === 'TK_COMMENT' || last_type === 'TK_STRING' || last_type === 'TK_START_BLOCK' || last_type === 'TK_END_BLOCK' || last_type === 'TK_SEMICOLON') {\r\n                print_newline();\r\n            } else if (last_type === 'TK_WORD') {\r\n                print_single_space();\r\n            } else {\r\n                if (opt_preserve_newlines && wanted_newline) {\r\n                    print_newline();\r\n                    output.push(indent_string);\r\n                }\r\n            }\r\n            print_token();\r\n            break;\r\n\r\n        case 'TK_EQUALS':\r\n            if (flags.var_line) {\r\n                // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done\r\n                flags.var_line_tainted = true;\r\n            }\r\n            print_single_space();\r\n            print_token();\r\n            print_single_space();\r\n            break;\r\n\r\n        case 'TK_COMMA':\r\n            if (flags.var_line) {\r\n                if (is_expression(flags.mode) || last_type === 'TK_END_BLOCK' ) {\r\n                    // do not break on comma, for(var a = 1, b = 2)\r\n                    flags.var_line_tainted = false;\r\n                }\r\n                if (flags.var_line_tainted) {\r\n                    print_token();\r\n                    flags.var_line_reindented = true;\r\n                    flags.var_line_tainted = false;\r\n                    print_newline();\r\n                    break;\r\n                } else {\r\n                    flags.var_line_tainted = false;\r\n                }\r\n\r\n                print_token();\r\n                print_single_space();\r\n                break;\r\n            }\r\n\r\n            if (last_type === 'TK_COMMENT') {\r\n                print_newline();\r\n            }\r\n\r\n            if (last_type === 'TK_END_BLOCK' && flags.mode !== \"(EXPRESSION)\") {\r\n                print_token();\r\n                if (flags.mode === 'OBJECT' && last_text === '}') {\r\n                    print_newline();\r\n                } else {\r\n                    print_single_space();\r\n                }\r\n            } else {\r\n                if (flags.mode === 'OBJECT') {\r\n                    print_token();\r\n                    print_newline();\r\n                } else {\r\n                    // EXPR or DO_BLOCK\r\n                    print_token();\r\n                    print_single_space();\r\n                }\r\n            }\r\n            break;\r\n\r\n\r\n        case 'TK_OPERATOR':\r\n\r\n            var space_before = true;\r\n            var space_after = true;\r\n            if (is_special_word(last_text)) {\r\n                // \"return\" had a special handling in TK_WORD. Now we need to return the favor\r\n                print_single_space();\r\n                print_token();\r\n                break;\r\n            }\r\n\r\n            // hack for actionscript's import .*;\r\n            if (token_text === '*' && last_type === 'TK_DOT' && !last_last_text.match(/^\\d+$/)) {\r\n                print_token();\r\n                break;\r\n            }\r\n\r\n            if (token_text === ':' && flags.in_case) {\r\n                flags.case_body = true;\r\n                indent();\r\n                print_token();\r\n                print_newline();\r\n                flags.in_case = false;\r\n                break;\r\n            }\r\n\r\n            if (token_text === '::') {\r\n                // no spaces around exotic namespacing syntax operator\r\n                print_token();\r\n                break;\r\n            }\r\n\r\n            if (in_array(token_text, ['--', '++', '!']) || (in_array(token_text, ['-', '+']) && (in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS', 'TK_OPERATOR']) || in_array(last_text, line_starters) || last_text == ','))) {\r\n                // unary operators (and binary +/- pretending to be unary) special cases\r\n\r\n                space_before = false;\r\n                space_after = false;\r\n\r\n                if (last_text === ';' && is_expression(flags.mode)) {\r\n                    // for (;; ++i)\r\n                    //        ^^^\r\n                    space_before = true;\r\n                }\r\n                if (last_type === 'TK_WORD' && in_array(last_text, line_starters)) {\r\n                    space_before = true;\r\n                }\r\n\r\n                if (flags.mode === 'BLOCK' && (last_text === '{' || last_text === ';')) {\r\n                    // { foo; --i }\r\n                    // foo(); --bar;\r\n                    print_newline();\r\n                }\r\n            } else if (token_text === ':') {\r\n                if (flags.ternary_depth === 0) {\r\n                    if (flags.mode === 'BLOCK') {\r\n                        flags.mode = 'OBJECT';\r\n                    }\r\n                    space_before = false;\r\n                } else {\r\n                    flags.ternary_depth -= 1;\r\n                }\r\n            } else if (token_text === '?') {\r\n                flags.ternary_depth += 1;\r\n            }\r\n            if (space_before) {\r\n                print_single_space();\r\n            }\r\n\r\n            print_token();\r\n\r\n            if (space_after) {\r\n                print_single_space();\r\n            }\r\n\r\n            break;\r\n\r\n        case 'TK_BLOCK_COMMENT':\r\n\r\n            var lines = split_newlines(token_text);\r\n            var j; // iterator for this case\r\n\r\n            if (all_lines_start_with(lines.slice(1), '*')) {\r\n                // javadoc: reformat and reindent\r\n                print_newline();\r\n                output.push(lines[0]);\r\n                for (j = 1; j < lines.length; j++) {\r\n                    print_newline();\r\n                    output.push(' ');\r\n                    output.push(trim(lines[j]));\r\n                }\r\n\r\n            } else {\r\n\r\n                // simple block comment: leave intact\r\n                if (lines.length > 1) {\r\n                    // multiline comment block starts with a new line\r\n                    print_newline();\r\n                } else {\r\n                    // single-line /* comment */ stays where it is\r\n                    if (last_type === 'TK_END_BLOCK') {\r\n                        print_newline();\r\n                    } else {\r\n                        print_single_space();\r\n                    }\r\n\r\n                }\r\n\r\n                for (j = 0; j < lines.length; j++) {\r\n                    output.push(lines[j]);\r\n                    output.push(\"\\n\");\r\n                }\r\n\r\n            }\r\n            if (look_up('\\n') !== '\\n') {\r\n                print_newline();\r\n            }\r\n            break;\r\n\r\n        case 'TK_INLINE_COMMENT':\r\n            print_single_space();\r\n            print_token();\r\n            if (is_expression(flags.mode)) {\r\n                print_single_space();\r\n            } else {\r\n                force_newline();\r\n            }\r\n            break;\r\n\r\n        case 'TK_COMMENT':\r\n\r\n            if (last_text === ',' && !wanted_newline) {\r\n                trim_output(true);\r\n            }\r\n            if (last_type !== 'TK_COMMENT') {\r\n                if (wanted_newline) {\r\n                    print_newline();\r\n                } else {\r\n                    print_single_space();\r\n                }\r\n            }\r\n            print_token();\r\n            print_newline();\r\n            break;\r\n\r\n        case 'TK_UNKNOWN':\r\n            print_token();\r\n            break;\r\n        }\r\n\r\n        last_last_text = last_text;\r\n        last_type = token_type;\r\n        last_text = token_text;\r\n    }\r\n\r\n    var sweet_code = preindent_string + output.join('').replace(/[\\r\\n ]+$/, '');\r\n    return sweet_code;\r\n\r\n}\r\n\r\n// Add support for CommonJS. Just put this file somewhere on your require.paths\r\n// and you will be able to `var js_beautify = require(\"beautify\").js_beautify`.\r\nif (typeof exports !== \"undefined\") {\r\n    exports.js_beautify = js_beautify;\r\n}\r\n\r\nvar Beautifier = {\r\n  js: function(content) {\r\n    return js_beautify(content, {\r\n      indent_size: 4,\r\n      space_before_conditional: true,\r\n      jslint_happy: true,\r\n      max_char: 0\r\n    });\r\n  },\r\n  html: function(content) {\r\n    return style_html(content, {\r\n      indent_size: 4,\r\n      max_char: 0\r\n    });\r\n  },\r\n  css: function(content) {\r\n    return css_beautify(content, {\r\n      indent_size: 4,\r\n      max_char: 0\r\n    });\r\n  }\r\n}"]],"start1":0,"start2":0,"length1":0,"length2":74799}]],"length":74799,"saved":false}
